/*
 * select.cpp
 *
 *  Created on: 2018 nov. 3
 *      Author: freeart
 */

#include "select.h"


SELECT::SELECT() {
	// TODO Auto-generated constructor stub
	//setDatabaseName("/home/freeart/MscThesis/CuDatBase/cudatbase/src/example.txt");
	testFunction();
	m_dataList_v.empty();

	//For test without Qt
	m_dataBasePath_str = "/home/freeart/MscThesis/CuDatBase/cudatbase/src/honda_test.csv" ;
	m_delimeter_str = ";";
}

SELECT::SELECT(int a[5],int b[5],int c[5]) { //cuda_test call from qt
	// TODO Auto-generated constructor stub
	m_dataList_v.empty();

	//For test without Qt
	m_dataBasePath_str = "/home/freeart/MscThesis/CuDatBase/cudatbase/src/honda_test.csv" ;
	m_delimeter_str = ";";

	testFunction();
	callExample(a,b,c); //cuda_test
}

SELECT::~SELECT() {
	// TODO Auto-generated destructor stub
}

void SELECT::testFunction()
{
	testCuda();
}
//For test period
void SELECT::loadDatabase(){
	CSVReader *reader = new CSVReader(m_dataBasePath_str,m_delimeter_str);
	m_dataList_v =  reader->getData();

	delete reader;

}
//In the future
void SELECT::loadDatabase(const vector<vector<string> > &l_dataBase_v){
	m_dataList_v = l_dataBase_v;
}

void SELECT::showDatabase() const{

	for(vector<string> vec : m_dataList_v)
	    {
	        for(string vector_member : vec)
	        {
	            cout<<vector_member << ";";
	        }
	        cout<<std::endl;
	    }
}

void SELECT::readSelectRule(vector<string> l_selectRule_v){
	m_selectRule_v = l_selectRule_v;
}

void SELECT::run(){

}

void SELECT::or_method(vector<vector<string>> *l_collectDataVector_p,vector<vector<string>> &l_OR_collectDataVector_r){
	l_collectDataVector_p = &l_OR_collectDataVector_r;
	l_collectDataVector_p->clear();
}

void SELECT::and_method(vector<vector<string>> *l_collectDataVector_p, const vector<vector<string>> &l_OR_collectDataVector_r,
        vector<vector<string>> &l_AND_collectDataVector_r, vector<vector<string> > &l_workDataVector)
{

    or_and_merge(l_collectDataVector_p,l_OR_collectDataVector_r,l_AND_collectDataVector_r);

    l_collectDataVector_p = &l_AND_collectDataVector_r;

    l_workDataVector.clear();
    l_workDataVector = l_AND_collectDataVector_r;
    l_collectDataVector_p->clear();
}

void SELECT::or_and_merge(const vector<vector<string> > *l_collectDataVector_p, const vector<vector<string>> &l_OR_collectDataVector_r,
        vector<vector<string>> &l_AND_collectDataVector_r)
{
    if((void*)l_collectDataVector_p == &l_OR_collectDataVector_r)
    {
        l_AND_collectDataVector_r.insert(l_AND_collectDataVector_r.end(), l_OR_collectDataVector_r.begin(), l_OR_collectDataVector_r.end());
    }
}

void SELECT::equal(int input, string l_SelectRule_str, const vector<vector<string>> &dataBase_r,
		vector<vector<string>> *l_collectDataVector_p, vector<vector<string> > &l_workDataVector){

}
